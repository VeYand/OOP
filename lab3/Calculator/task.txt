Задание 2 – Калькулятор – 300 баллов
Разработать с использованием подхода TDD программу «Калькулятор», позволяющую выполнять простейшие арифметические операции над переменными и пользовательскими функциями. Спроектируйте классы, моделирующих основные сущности предметной области, и напишите для них тесты.

Нарисуйте диаграмму классов получившейся программы (можно использовать программу draw.io, mermaid или аналоги, а также нарисовать на бумаге).

Формат входных и выходных данных

Входные данные поступают из stdin. Работа программы завершается при обнаружении конца файла. Каждая строка содержит одну из следующих команд:

var <идентификатор>

Объявляет переменную типа double с именем <идентификатор>. Идентификатор не должен совпадать ни с одним из ранее объявленных имен переменных и функций. Значение переменной после ее объявления не определено (можно использовать значение NAN для этих целей). В отсутствие ошибок в stdout ничего не выводится. При наличии ошибки команда игнорируется, а в stdout выводится текст ошибки.

let <идентификатор1> = <число с плавающей запятой> либо

let <идентификатор1> = <идентификатор2>.

Присваивает переменной с именем <идентификатор1> числовое значение, либо текущее значение ранее объявленного идентификатора с именем <идентификатор2>. Если переменная с именем <идентификатор1> не была ранее объявлена, происходит объявление новой переменной. В качестве <идентификатора1> не может выступать имя функции. В отсутствие ошибок в stdout ничего не выводится. В случае ошибки команда игнорируется, а в stdout выводится текст ошибки.

fn <идентификатор1> = <идентификатор2> либо

fn <идентификатор1> = <идентификатор2><операция><идентификатор3>

Объявляет новую функцию с ранее необъявленным именем <идентификатор1>, значением которой будет либо значение идентификатора <идентификатор2>, либо результат применения одной из следующих бинарных операций к значениям ранее объявленных идентификаторов <идентификатор2> и <идентификатор3> в момент вычисления значения функции:

+. Сложение.
-. Вычитание.
*. Умножение
/. Деление
Если значение хотя бы одного из операндов операции не определено, результатом операции должно быть неопределенное значение. В отсутствие ошибок в stdout ничего не выводится. В случае ошибки команда игнорируется, а в stdout выводится текст ошибки.

print <идентификатор>

Выводит в stdout значение ранее объявленного идентификатора. Если идентификатором являлась переменная, то выводится ее значение, а если функция, то выводится вычисленное значение функции. Значение идентификатора выводится с точностью в 2 знака после запятой. В случае, когда значение идентификатора не определено, должно быть выведено nan. В случае ошибки (например, попытка вывести значение необъявленного идентификатора), команда игнорируется, а в stdout должен быть выведен текст ошибки.

printvars

Выводит в stdout имена и значения всех ранее объявленных переменных, отсортированных по алфавиту, по одному в каждой строке в следующем формате:

<идентификатор>:<значение>

Значение переменной выводится с точностью 2 знака после запятой. Если значение переменной не определено, должно быть выведено nan. Если ни одной переменной не было объявлено к моменту выполнения команды printvars, в stdout выводиться ничего не должно.

printfns

Выводит в stdout имена и значения всех ранее объявленных функций, отсортированных по алфавиту, по одному в каждой строке в следующем формате:

<идентификатор>:<значение>

Значение функции выводится с точностью в 2 знака после запятой. Если значение функции не определено, должно быть выведено nan. Если ни одной функции не было объявлено к моменту выполнения команды printfns, в stdout выводиться ничего не должно

Идентификатором является непустая строка, в которой допускается использовать буквы английского алфавита, цифры и символ подчеркивания. Идентификатор не может начинаться с цифры. Идентификаторы используются в качестве имен переменных и функций.

Идентификаторы и названия команд являются чувствительными к регистру символов.

Примеры

Объявление, присваивание и вывод значений переменных

stdin	stdout	Пояснение
var x
print x	nan	Значение переменной x пока не определено
let x=42		Присваиваем переменной x значение 42
print x	42.00
let x=1.234		Значение переменной можно изменить
print x	1.23	Значение выводится с точностью 2 знака после запятой
let y=x		Автоматически объявляем переменную y и присваиваем ей текущее значение x
let x=99
printvars	x:99.00
y:1.23	Переменная y хранит присвоенное ей значение x. Последующие манипуляции над x не оказывают на нее влияния.
Объявление функций

stdin	stdout	Пояснение
var x
var y
fn XPlusY=x+y
print XPlusY	nan	Значение функции не определено, т.к. не определены значения ее аргументов
let x=3
let y=4
print XPlusY	7.00	Теперь значение функции определено
let x=10
print XPlusY	14.00	Значение функции зависит от значений ее аргументов
let z=3.5
fn XPlusYDivZ=XPlusY/z		Значение функции может зависеть не только от значений переменных, но и от значений других функций
printfns	XPlusY:14.00
XPlusYDivZ:4.00	Значения функций выводятся в алфавитном порядке
Еще раз про различие между fn и let

Stdin	stdout	Пояснение
let v=42
let variable=v		variable хранит значение v (42)
fn function=v		function хранит действие, которое будет вычислено при получении значения функции
let v=43
print variable	42.00
print function	43.00	Значением function будет значение переменной v, вычисленное в момент вызова функции (а не ее объявления)
Вычисление площади круга

Stdin	stdout	Пояснение
var radius
let pi=3.14159265
fn radiusSquared=radius*radius
fn circleArea=pi*radiusSquared
let radius=10
print circleArea	314.16
let circle10Area=circleArea		circle10Area хранит значение функции circleArea, вычисленной при radius=10
let radius=20
let circle20Area=circleArea		circle20Area хранит значение функции circleArea, вычисленной при radius=20
printfns	circleArea:1256.64
radiusSquared:400.00
printvars	circle10Area:314.16
circle20Area:1256.64
pi:3.14
radius:20.00
Вычисление последовательности Фибоначчи

Stdin	stdout	Пояснение
let v0=0
let v1=1
fn fib0=v0
fn fib1=v1
fn fib2=fib1+fib0
fn fib3=fib2+fib1
fn fib4=fib3+fib2
fn fib5=fib4+fib3
fn fib6=fib5+fib4
printfns	fib0:0.00
fib1:1.00
fib2:1.00
fib3:2.00
fib4:3.00
fib5:5.00
fib6:8.00
let v0=1
let v1=1
printfns	fib0:1.00
fib1:1.00
fib2:2.00
fib3:3.00
fib4:5.00
fib5:8.00
fib6:13.00
Бонус в 200 баллов за оптимизацию вычислений функций

Наивный подход к вычислению значений функций может в ряде случаев приводить к экспоненциальной вычислительной сложности. Например, попытка вычислить значение хотя бы 50-го числа последовательности Фибоначчи, заданного в виде «рекурсивной» последовательности функций, потребует весьма продолжительного времени. Придумайте способ, позволяющий значительно сократить вычислительную сложность алгоритма в таких ситуациях.

Бонус в 100 баллов за возможность вычисления очень больших последовательностей функций

Использование рекурсии в процессе вычислений функций с большой глубиной вычислений (десятки или сотни тысяч) может привести к переполнению стека (win32-приложениям по умолчанию доступно около 2МБ стека). Придумайте способ решить проблему с переполнением стека из-за глубокой рекурсии, не изменяя размер стека в настройках компоновщика.

Пример входных данных, которые потенциально могут приводить к указанной проблеме:

stdin	stdout	Пояснение
let x=1
fn x2=x+x
fn x3=x2+x
fn x4=x3+x
fn x5=x3+x
…
fn x1000000=x999999+x		Объявляется большая последовательность функций, каждая из которых прибавляет x к значению предыдущей функции.
print x1000000	1000000.00	Наивное рекурсивное вычисление функции x1000000 может привести к переполнению стека.
let x=2
print x1000000	2000000.00