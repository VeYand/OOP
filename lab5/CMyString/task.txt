Задание 7
Задание 2 – До 300 баллов
Реализовать и протестировать класс CMyString, моделирующий строку произвольной длины.

Внимание, строка должна позволять хранить в середине символы с нулевым кодом (подсказка: реализация класса строк должна помимо адреса первого элемента массива символов в динамической памяти хранить еще и длину строки, т.к. использование функций вроде strlen, strcpy и им подобных, воспринимающих символ с нулевым кодом как символ конца строки, не решает данную проблему. Кроме того в массиве потребуется зарезервировать место под символ с нулевым кодом в конце строки, т.к. метод GetStringData(), объявленный в классе CMyString, согласно условиям задачи возвращает указатель на строку с завершающим нулевым символом.). Проинициализировать такую строку можно при помощи конструктора, принимающего кроме адреса первого символа длину строки.

Каркас класса:

class CMyString
{
public:
    // конструктор по умолчанию
    CMyString();

    // конструктор, инициализирующий строку данными строки
    // с завершающим нулевым символом
    CMyString(const char * pString);

    // конструктор, инициализирующий строку данными из 
    // символьного массива заданной длины
    CMyString(const char * pString, size_t length);

    // конструктор копирования
    CMyString(CMyString const& other);

    // перемещающий конструктор (для компиляторов, совместимых с C++11)
    //  реализуется совместно с перемещающим оператором присваивания 
    CMyString(CMyString && other);

    // конструктор, инициализирующий строку данными из 
    // строки стандартной библиотеки C++
    CMyString(std::string const& stlString);

    // деструктор класса - освобождает память, занимаемую символами строки
    ~CMyString();

    // возвращает длину строки (без учета завершающего нулевого символа)
    size_t GetLength()const;

    // возвращает указатель на массив символов строки.
    // В конце массива обязательно должен быть завершающий нулевой символ
    // даже если строка пустая 
    const char* GetStringData()const;

    // возвращает подстроку с заданной позиции длиной не больше length символов
    CMyString SubString(size_t start, size_t length = SIZE_MAX)const;

    // очистка строки (строка становится снова нулевой длины)
    void Clear();
};
Для хранения символов строки не допускается использовать классы вроде std::string и std::vector. Управление данными в динамической памяти должно быть реализовано целиком силами Вашего класса.

Внимание:

Реализуйте конструктор, деструктор и перечисленные в каркасе методы класса, а также следующие операторы:

№	Оператор	Описание
1	=	Присваивание CMyString (присваивание других типов, принимаемые конструктором класса будут реализованы автоматически)
Корректно должна обрабатываться ситуации с самоприсваиванием, вроде:
CMyString s(“SomeString”);
s = s;
2	+	Реализуйте следующие версии оператора конкатенации:
1.CMyString с CMyString
2.std::string с CMyString
3.const char* с CMyString
3	+=	Конкатенация CMyString с CMyString с присваиванием
4	==	Посимвольное сравнение содержимого двух строк
5	!=	Проверка двух строк на неравенство
6	<	Лексикографическое сравнение содержимого двух строк. Осуществляет проверку того, предшествует ли строка слева от знака «<» строке, находящейся справа, если сравнивать их содержимое в алфавитном порядке.
7	>	Лексикографическое сравнение содержимого двух строк. Аналогично оператору <
8	<= и >=	Лексикографическое сравнение содержимого двух строк. Аналогично операторам < и >
9	[]	Реализуйте две версии данного оператора:
1.Индексированный доступ к символам строки по целочисленному индексу для чтения
2.Индексированный доступ к символам строки по целочисленному индексу для записи
10	<<	Оператор вывода в выходной поток
11	>>	Оператор ввода из входного потока
12	Перемещающий конструктор и оператор присваивания	Реализуется совместно с перемещающим конструктором.
Бонус до 200 баллов за реализацию STL-совместимых итераторов

Реализовать поддержку итераторов в STL-совместимой манере, позволяющих перебирать символы строки, использоваться совместно с основными алгоритмами стандартной библиотеки.

№	Функционал	Балл	Обязательно
1	Итерация по константным (для константных строк должен возвращаться итератор, предоставляющий доступ к содержимому строки только для чтения) и неконстантным строкам в прямом направлении и обратном направлении.
Получение итератора, указывающего на начальный символ и на позицию, следующую за конечным символом строки (аналоги методов begin()/end() класса std::string)
Разыменование итератора
Нахождение разницы между двумя итераторами, сложение итератора с числом и числа с итератором	100	Да
2	Индексированный (для константных строк доступ должен предоставляться только для чтения символов строки) доступ к элементам строки относительно итератора при помощи оператора []	20	Нет
3	Поддержка итерации по символам строки в обратном направлении (аналогично итерации при помощи методов std::string::rbegin(), std::string::rend()).	30	Нет
4	Проверка границ (при помощи assert) в отладочной конфигурации.	30	Нет
5	Поддержка итерации по элементам при помощи range-based версии оператора for.	20	Нет
В процессе разработки классов использование подхода TDD обязательно. Без автоматических тестов работа будет принята с коэффициентом 0.5.